<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Nginx笔记 - Wayne&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Wayne" /><meta name="description" content="1. Nginx架构 1.1. Nginx处理流程 Nginx使用Epoll的非租塞事件驱动模型，内部有三种状态机： 传输层状态机，接收四层请求 HTTP状态机" /><meta name="keywords" content="theme, even" />






<meta name="generator" content="Hugo 0.59.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/2020-09-13-nginx%E7%AC%94%E8%AE%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.6eb09ed45a88bd339269c14515d2a11f2e0afdadbdd763d83f9b5c797166b081.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Nginx笔记" />
<meta property="og:description" content="1. Nginx架构 1.1. Nginx处理流程 Nginx使用Epoll的非租塞事件驱动模型，内部有三种状态机： 传输层状态机，接收四层请求 HTTP状态机" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/2020-09-13-nginx%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2020-09-13T20:38:26+08:00" />
<meta property="article:modified_time" content="2020-09-13T20:38:26+08:00" />
<meta itemprop="name" content="Nginx笔记">
<meta itemprop="description" content="1. Nginx架构 1.1. Nginx处理流程 Nginx使用Epoll的非租塞事件驱动模型，内部有三种状态机： 传输层状态机，接收四层请求 HTTP状态机">


<meta itemprop="datePublished" content="2020-09-13T20:38:26&#43;08:00" />
<meta itemprop="dateModified" content="2020-09-13T20:38:26&#43;08:00" />
<meta itemprop="wordCount" content="8170">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Nginx笔记"/>
<meta name="twitter:description" content="1. Nginx架构 1.1. Nginx处理流程 Nginx使用Epoll的非租塞事件驱动模型，内部有三种状态机： 传输层状态机，接收四层请求 HTTP状态机"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Wayne</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Wayne</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Nginx笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-09-13 </span>
        
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#1-nginx架构">1. Nginx架构</a>
<ul>
<li><a href="#1-1-nginx处理流程">1.1. Nginx处理流程</a></li>
<li><a href="#1-2-nginx进程结构">1.2. Nginx进程结构</a></li>
<li><a href="#1-3-使用信号管理进程">1.3. 使用信号管理进程</a></li>
<li><a href="#1-4-reload的过程">1.4. reload的过程</a></li>
<li><a href="#1-5-热升级以及回滚">1.5. 热升级以及回滚</a></li>
<li><a href="#1-6-优雅关闭worker进程">1.6. 优雅关闭worker进程</a></li>
<li><a href="#1-7-nginx事件驱动模型epoll">1.7. Nginx事件驱动模型Epoll</a></li>
<li><a href="#1-8-同步-异步-阻塞-非租塞的区别">1.8. 同步&amp;异步、阻塞&amp;非租塞的区别</a>
<ul>
<li><a href="#阻塞调用">阻塞调用</a></li>
<li><a href="#非租塞调用">非租塞调用</a></li>
</ul></li>
<li><a href="#1-9-nginx的模块">1.9. Nginx的模块</a></li>
<li><a href="#1-11-worker进程间的协同工作">1.11. worker进程间的协同工作</a></li>
</ul></li>
<li><a href="#2-http模块">2. HTTP模块</a>
<ul>
<li><a href="#2-1-冲突的配置指令优先级">2.1. 冲突的配置指令优先级</a>
<ul>
<li><a href="#配置快的嵌套">配置快的嵌套</a></li>
<li><a href="#指令的context">指令的Context</a></li>
<li><a href="#指令的合并">指令的合并</a></li>
</ul></li>
<li><a href="#2-2-listen指令的用法">2.2. listen指令的用法</a></li>
<li><a href="#2-3-正则表达式">2.3. 正则表达式</a></li>
<li><a href="#2-4-server指令块查找">2.4. server指令块查找</a>
<ul>
<li><a href="#server-name指令">server_name指令</a></li>
<li><a href="#server匹配顺序">server匹配顺序</a></li>
</ul></li>
<li><a href="#2-5-http请求的11个阶段">2.5. HTTP请求的11个阶段</a>
<ul>
<li><a href="#11个阶段的处理顺序">11个阶段的处理顺序</a></li>
<li><a href="#2-5-1-获取用户真实ip的realip模块">2.5.1 获取用户真实ip的realip模块</a></li>
<li><a href="#2-5-2-rewrite阶段的rewrite指令和return">2.5.2 rewrite阶段的rewrite指令和return</a>
<ul>
<li>
<ul>
<li><a href="#return与error-page">return与error_page</a></li>
</ul></li>
</ul></li>
<li><a href="#2-5-3-rewrite重写url">2.5.3 rewrite重写url</a></li>
<li><a href="#2-5-4-条件判断if">2.5.4. 条件判断if</a></li>
<li><a href="#2-5-5-find-config找到处理请求的location">2.5.5. find_config找到处理请求的location</a></li>
<li><a href="#2-5-6-对连接数限制的limit-conn">2.5.6. 对连接数限制的limit_conn</a></li>
<li><a href="#2-5-7-对连接数限制的limit-req">2.5.7. 对连接数限制的limit_req</a></li>
<li><a href="#2-5-8-对ip做限制的access模块">2.5.8. 对ip做限制的access模块</a></li>
<li><a href="#2-5-9-precontent阶段的try-files模块">2.5.9. precontent阶段的try_files模块</a></li>
</ul></li>
<li><a href="#2-5-11-static模块的三个变量">2.5.11. static模块的三个变量</a>
<ul>
<li><a href="#2-5-12-static模块url后面斜杆问题">2.5.12. static模块url后面斜杆问题</a></li>
<li><a href="#2-5-13-access日志详细用法">2.5.13. access日志详细用法</a></li>
<li><a href="#2-5-14-http过滤模块">2.5.14. HTTP过滤模块</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h2 id="1-nginx架构">1. Nginx架构</h2>

<h3 id="1-1-nginx处理流程">1.1. Nginx处理流程</h3>

<p>Nginx使用Epoll的非租塞事件驱动模型，内部有三种状态机：</p>

<ol>
<li>传输层状态机，接收四层请求</li>
<li>HTTP状态机，处理七层事件</li>
<li>Mail状态机，处理邮件</li>
</ol>

<p>基于状态机，在nginx接收请求处理静态资源的时候，在静态目录找到静态资源，如果做反向代理的时候，从磁盘中缓存取，当nginx内存不足以缓存文件和信息的时候，sendfile活AIO会退化成阻塞的IO调用，因此需要一个线程池来处理调用。对于处理完成的请求会记录access和error日志。当进行反向代理的时候，可以通过协议或应用层代理到后端服务器。</p>

<h3 id="1-2-nginx进程结构">1.2. Nginx进程结构</h3>

<p>Nginx采用多进程而不是多线程模型的原因是进程之间是独立内存空间的，而多线程是共享内存地址空间的，如果某个线程出现内存问题，会导致整个nginx进程挂掉，而多进程则不会出现这样的问题。</p>

<p>Nginx进程包含一个Master的父进程和多个子进程，子进程包含worker进程和cache进程。master进程的目的是管理worker进程，所有的worker进程是处理真正的请求，master进程监控worker进程的运行，是不是需要载入新的配置文件、是不是要进行热部署。</p>

<p>缓存是不仅要在多个worker进程之间共享，而且也要被cache manager和cache loader进程使用，cache manager和cache load也是为反向代理时，后端发来的动态请求做缓存使用的。cache loader做缓存的载入，manager做缓存的管理。</p>

<p>进程之间的通信是使用共享内存来解决的。worker进程很多的原因是nginx采用事件驱动模型以后，希望nginx每个nginx进程都占用一颗CPU，所以不仅nginx一般配置进程数等于CPU核心数，而且最好为每个进程分配固定的CPU核更有效的利用CPU上的缓存来减少缓存失效降低命中率。</p>

<p>Tip：nginx reload和kill -SIGHUP pid是一样的</p>

<h3 id="1-3-使用信号管理进程">1.3. 使用信号管理进程</h3>

<ol>
<li><p>Master进程：</p>

<ul>
<li>监控worker进程CHLD信号，如果worker进程终止，会发送CHLD信号给master，如果worker进程意外终止，master可以立刻通过CHLD发现worker进程异常，会立刻拉起worker进程</li>
<li>管理worker进程</li>
<li>接收信号：

<ul>
<li>TERM，INT立刻停止进程</li>
<li>、QUIT优雅停止，保证不会对用户发reset报文</li>
<li>HUP重载配置</li>
<li>USR1重新打开日志文件，对日志文件切割</li>
<li>USR2平滑升级</li>
<li>WINCH优雅关闭旧的进程(配合USR2来进行升级)</li>
</ul></li>
</ul></li>

<li><p>Worker进程</p></li>
</ol>

<p>接收信号：TERM、INT、QUIT、USR1、WINCH，虽然worker也可以接收信号，但是通常不这么操作，都是有master来管理的</p>

<ol>
<li><p>Nginx命令行</p>

<ul>
<li>reload：HUP</li>
<li>reopen：USER1</li>
<li>stop：TERM</li>
<li>quit：QUIT</li>
</ul></li>
</ol>

<p>nginx接收命令和使用kill+信号处理的效果是一样的</p>

<h3 id="1-4-reload的过程">1.4. reload的过程</h3>

<p>在配置文件变更后，执行nginx -s reload会将新的配置文件应用，reload的流程：</p>

<ol>
<li>想master进程发送HUP信号（reload指令）</li>
<li>master进程校验配置语法是否正确（不一定非要执行-t指令校验）</li>
<li>master进程打开可能引入的新的监听端口</li>
<li>master进程用新的配置文件启动新的worker子进程</li>
<li>master进程向老的worker子进程发送QUIT信号优雅关闭。为了保证nginx的平滑，关闭老进程之前一定要保证新进程启动</li>
<li>老worker进程收到QUIT信号后，关闭监听句柄，处理完当前连接后结束进程。正常情况下老的worker进程都会正常退出。但是在一些特殊情况，比如连接出了问题，客户端长时间没有处理，导致老worker进程一直存在，新版的nginx通过参数<strong>worker_shutdown_timeout</strong>来释放异常超时的worker进程连接</li>
</ol>

<h3 id="1-5-热升级以及回滚">1.5. 热升级以及回滚</h3>

<ol>
<li>将旧的Nginx二进制文件替换成新的二进制文件（注意备份；替换时，由于文件被进程使用，所以用cp -f参数强制替换）</li>
<li>想master进程发送USER2信号</li>
<li>master进程修改pid文件名，加后缀.oldbin</li>
<li>用新Nginx文件启动新的master进程</li>
<li>想老的master进程发送WINCH信号（从第三部的备份pid文件找到进程号，或者ps查看），关闭老的worker进程</li>
<li>回滚：向老master发送HUP信号，向新master发送QUIT</li>
</ol>

<h3 id="1-6-优雅关闭worker进程">1.6. 优雅关闭worker进程</h3>

<p>如果直接关闭worker进程，会导致正在连接的用户收到异常信息，优雅的关闭是指worker进程可以识别出当前的连接没有处理请求，然后把进程关闭。优雅关闭只针对HTTP请求</p>

<ol>
<li>设置定时器work_shutdown_timeout</li>
<li>关闭监听句柄</li>
<li>关闭空闲连接</li>
<li>在循环中等待全部链接关闭，这个等待时间可能会比较长，可能会超过work_shutdown_timeout设置时间，当达到work_shutdown_timeout时间，就会被强制关闭</li>
<li>退出进程</li>
</ol>

<h3 id="1-7-nginx事件驱动模型epoll">1.7. Nginx事件驱动模型Epoll</h3>

<p>在建立了百万并发的连接时，同时活跃的连接可能只有几百个，只需要处理着几百个请求，而select或poll每次取操作系统事件时，会把这百万连接都交给操作系统，由操作系统判断哪些连接有请求进来。Epoll就是用了前者。</p>

<p>Epoll的实现：Epoll维护了eventpoll，它通过两个数据结构将两个事件分开，nginx每次取活跃连接的时候，会遍历一个链表，这个链表里只有活跃的连接，从内核态读取到用户态，这样效率就很高。</p>

<p>通常可以将worker进程的优先级调高（比如-19），这样CPU会给worker进程分配的时间片比较大，避免进程切换，一个县城仅处理一个连接，不做连接切换，依赖OS的进程调度实现并发。一线程同时处理多连接，在用户态代码完成连接切换，尽量减少OS进程切换。</p>

<h3 id="1-8-同步-异步-阻塞-非租塞的区别">1.8. 同步&amp;异步、阻塞&amp;非租塞的区别</h3>

<p>以Accept为例：</p>

<h4 id="阻塞调用">阻塞调用</h4>

<p>阻塞Accept请求，调用Accept，正常Accept不为空会立即返回；但是如果Accept队列为空时，操作系统会等待新的三次握手的连接到达内核中去唤醒Accept调用。这个过程会导致进程的切换，对于nginx是不能容忍进程切换的。</p>

<h4 id="非租塞调用">非租塞调用</h4>

<p>调用Accept时，监听套接字设置为非租塞，如果Accept队列为空，则不等待，立刻返回EAGAIN错误，代码会进行处理。所以，这里由代码决定是否切换新任务。</p>

<h3 id="1-9-nginx的模块">1.9. Nginx的模块</h3>

<ul>
<li>前提编译进nginx</li>
<li>提供哪些配置项</li>
<li>模块何时被使用（编译即使用还是显示配置）</li>
<li>提供哪些变量</li>
</ul>

<p>### 1.10. Nginx如何通过连接池处理网络请求</p>

<p>syntax: worker_connections |default 512 | context events</p>

<p>配置一个worker进程最大同时建立连接数，该连接数用于客户端与nginx、nginx与上游服务器的连接，因此，一个客户端的请求需要消耗两个连接。每个连接对应一个读事件和写事件。</p>

<p>内存池配置：</p>

<p>Syntax: connection_pool_size</p>

<h3 id="1-11-worker进程间的协同工作">1.11. worker进程间的协同工作</h3>

<p>Nginx进程间的通信方式</p>

<ol>
<li>信号</li>
<li>共享内存，多个进程可以同时使用，避免竞争问题需要加锁</li>
</ol>

<h2 id="2-http模块">2. HTTP模块</h2>

<h3 id="2-1-冲突的配置指令优先级">2.1. 冲突的配置指令优先级</h3>

<h4 id="配置快的嵌套">配置快的嵌套</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></pre></td>
<td class="lntd">
<pre class="chroma">main
http{
  upstream{}
  split_client{}
  map{}
  geo{}
  server{
    if(){}
    location{
      limit_except{}
    }
    location {
      location {     
      }
    }
  }
  server{}
}</pre></td></tr></table>
</div>
</div>
<h4 id="指令的context">指令的Context</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">Syntax<span class="p">:</span><span class="w"> </span>log_format<span class="w"> </span>name;<span class="w">
</span><span class="w"></span>Default<span class="p">:</span><span class="w"> </span>log_format<span class="w"> </span>combined<span class="w"> </span><span class="s2">&#34;...&#34;</span>;<span class="w">
</span><span class="w"></span>Context<span class="p">:</span><span class="w"> </span>http<span class="w">
</span><span class="w">
</span><span class="w"></span>Syntax<span class="p">:</span><span class="w"> </span>access_log<span class="w">
</span><span class="w"></span>Default<span class="p">:</span><span class="w"> </span>access_log<span class="w"> </span>logs/access.log<span class="w"> </span>combined;<span class="w">
</span><span class="w"></span>Context<span class="p">:</span><span class="w"> </span>http<span class="p">,</span>server<span class="p">,</span>location<span class="p">,</span>if<span class="w"> </span>in<span class="w"> </span>location<span class="p">,</span>limit_except</code></pre></td></tr></table>
</div>
</div>
<p>log_format只能存在于http块，而access_log可以存在于很多模块内</p>

<h4 id="指令的合并">指令的合并</h4>

<ul>
<li>直指令：存储配置项的值</li>
</ul>

<p>不同块下可以合并，存储值指令继承规则向上覆盖，子配置不存在，直接使用父配置；子配置存在则覆盖父配置。例如root；access_log；gzip。</p>

<ul>
<li>动作类指令：指定行为</li>
</ul>

<p>不同块下不可以合并，例如：rewrite，proxy_pass，当指令执行到这个位置时，必须立刻执行这种行为。生效阶段：server_rewrite阶段；rewrite阶段；content阶段</p>

<h3 id="2-2-listen指令的用法">2.2. listen指令的用法</h3>

<ul>
<li>listen unix:/var/run/nginx.sock;</li>
<li>listen 127.0.0.1:8080;</li>
<li>listen 127.0.0.1;</li>
<li>isten 8080;</li>
<li>listen *:8080;</li>
<li>listen localhost:8080 bind;</li>
<li>listen [::]8080 ipv6only=on;</li>
<li>listen[::1];</li>
</ul>

<h3 id="2-3-正则表达式">2.3. 正则表达式</h3>

<table>
<thead>
<tr>
<th align="center">代码</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>

<tr>
<td align="center">\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>

<tr>
<td align="center">\s</td>
<td>匹配任意空白字符</td>
</tr>

<tr>
<td align="center">\d</td>
<td>匹配数字</td>
</tr>

<tr>
<td align="center">\b</td>
<td>匹配单词的开始或结束</td>
</tr>

<tr>
<td align="center">^</td>
<td>匹配字符串的开始</td>
</tr>

<tr>
<td align="center">$</td>
<td>匹配字符串结束</td>
</tr>

<tr>
<td align="center">*</td>
<td>重复0或更多次</td>
</tr>

<tr>
<td align="center">+</td>
<td>重复1或多次</td>
</tr>

<tr>
<td align="center">？</td>
<td>重复0或1次</td>
</tr>

<tr>
<td align="center">{n}</td>
<td>重复n次</td>
</tr>

<tr>
<td align="center">{n,}</td>
<td>重复n或多次</td>
</tr>

<tr>
<td align="center">{n,m}</td>
<td>重复n到m次</td>
</tr>

<tr>
<td align="center"></td>
<td>转译</td>
</tr>

<tr>
<td align="center">（）</td>
<td>分组</td>
</tr>
</tbody>
</table>

<h3 id="2-4-server指令块查找">2.4. server指令块查找</h3>

<h4 id="server-name指令">server_name指令</h4>

<ul>
<li><p>*泛域名：仅支持最前或最后，例如：server_name *.example.com</p></li>

<li><p>正则表达式：server_name www.example.com ~^www\d+\.example.com，使用正则表达式，前面需要加上~^</p></li>

<li><p>.example.com 可以匹配 example.com  *.example.com</p></li>

<li><p>server<em>name 后面写 &ldquo;</em>&rdquo; 表示匹配所有域名</p></li>
</ul>

<p>指令后可以跟多个域名，第一个是主域名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax server_name_in_redirect on|off
Default server_name_in_redirect off
Context http,server,location</pre></td></tr></table>
</div>
</div>
<p>在多域名的时候，当使用return指令开启重定向时，默认的请求返回的重定向地址就是请求的地址，当设置server_name_in_redirect为on时，请求任一域名都会重定向到主域名</p>

<p>用正则表达式创建变量：用小()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">server {
	server_name ~^(www\.)?(.+)$;
	location / {
			root /sites/$2; # $2就是取的domain中的(.+)
	}
}</pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">server {
		server_name ~^(www\.)?(?&lt;domain&gt;.+)$;  # 匿名变量?&lt;domain&gt;
		location / {
				root /sites/$domain;
		}
}</pre></td></tr></table>
</div>
</div>
<h4 id="server匹配顺序">server匹配顺序</h4>

<ol>
<li>精确匹配</li>
<li>*在前的域名</li>
<li>*在后的域名</li>
<li>按文件中出现的顺序匹配正则表达式域名</li>
<li>default server

<ul>
<li>server块下第一个就是default server</li>
<li>可以在listen后加上default指定为default server</li>
</ul></li>
</ol>

<h3 id="2-5-http请求的11个阶段">2.5. HTTP请求的11个阶段</h3>

<p>当nginx接收完header时，就会按照这11个阶段来处理请求</p>

<table>
<thead>
<tr>
<th>Stage</th>
<th>Module</th>
</tr>
</thead>

<tbody>
<tr>
<td>POST_READ</td>
<td>realip</td>
</tr>

<tr>
<td>SERVER_REWRITE</td>
<td>rewrite</td>
</tr>

<tr>
<td>FIND_CONFIG</td>
<td></td>
</tr>

<tr>
<td>REWRITE</td>
<td>rewrite</td>
</tr>

<tr>
<td>POST_REWRITE</td>
<td></td>
</tr>

<tr>
<td>PREACCESS</td>
<td>limit_conn,limit_req</td>
</tr>

<tr>
<td>ACCESS</td>
<td>Auth_basic,access,auth_request</td>
</tr>

<tr>
<td>POST_ACCESS</td>
<td></td>
</tr>

<tr>
<td>PRECONTENT</td>
<td>Try_files</td>
</tr>

<tr>
<td>CONTENT</td>
<td>Index,autoindex,concat</td>
</tr>

<tr>
<td>LOG</td>
<td>Access_log</td>
</tr>
</tbody>
</table>

<h4 id="11个阶段的处理顺序">11个阶段的处理顺序</h4>

<p><img src="/images/posts/nginx_request_11stages.jpg" alt="" /></p>

<p>同一个阶段的各个模块也并不一定都会执行到，执行顺序和处理流程。</p>

<h4 id="2-5-1-获取用户真实ip的realip模块">2.5.1 获取用户真实ip的realip模块</h4>

<p>如何拿到用户真实IP</p>

<ol>
<li>TCP连接四元组</li>
<li>HTTP头部X-Forward-For用于传递IP</li>
<li>HTTP头部X-Real-IP用于传递用户IP</li>
<li>网络中存在许多反向代理</li>
</ol>

<p>X-Forward-For与X-Real-IP的区别是，X-Forward-For会将用户真实ip地址与经过链路代理的IP地址全部记录下来传递给nginx，而X-Real-IP只能保存一个地址就是用户的真实IP地址。</p>

<p>拿到用户真实IP后基于变量来使用，例如binary_remote_addr,remote_addr这样的变量的值就是真实IP。利用这两个变量来做连接限制才有意义，所以limit_conn模块一定要在PRE_ACCESS阶段而不能在POST_ACCESS阶段。</p>

<p>realip模块默认是不会编译到nginx的，需要通过&ndash;with-http_realip_module启用功能。它的功能是修改客户端地址。它修改了原来的remote_addr和remote_port变量，因此如果还想使用原来的变量，需要使用realip_remote_addr和realip_remote_port两个变量。</p>

<p>realip模块的指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">set_real_ip_from
real_ip_header X-Real-IP|X-Forward-For|proxy_protocol ,默认是X-Real-IP
real_ip_recursive 环回地址，如果real_ip_header是X-Forward-For ，开启它会取X-Forward-For与客户端相同ip的上一个ip</pre></td></tr></table>
</div>
</div>
<h4 id="2-5-2-rewrite阶段的rewrite指令和return">2.5.2 rewrite阶段的rewrite指令和return</h4>

<p>rewrite模块执行后，后续的其他模块都无法执行</p>

<ol>
<li><p>return指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: return code [text] | code URL | URL
Context server,location,if</pre></td></tr></table>
</div>
</div></li>
</ol>

<p>返回状态码：</p>

<ul>
<li>nginx自定义 444：关闭连接</li>
<li>http1.0标准：

<ul>
<li>301：http1.0永久重定向</li>
<li>302：临时重定向，禁止被缓存</li>
</ul></li>
<li>http1.1标准：

<ul>
<li>303：临时重定向，允许改变方法，禁止被缓存</li>
<li>307：临时重定向，不允许改变方法，禁止被缓存</li>
<li>308：永久重定向，不允许改变方法</li>
</ul></li>
</ul>

<h6 id="return与error-page">return与error_page</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: error_page code ...[=[response]] uri;
Default: -
Context: http,server,location,if in location</pre></td></tr></table>
</div>
</div>
<p>error_page 收到返回码的时候可以重定向到其他返回码，也可以返回个页面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></pre></td>
<td class="lntd">
<pre class="chroma">error_page 404 /404.html
error_page 404 =200 /empty.gif;
location / {
		error_page 404 =@fallback
}

location @fallback {
		proxy_pass http://backend;
}
error_page 403 http://example.com/forbidden.html
error_page 404 =301 http://example.com/notfounnd.html</pre></td></tr></table>
</div>
</div>
<p>与return的区别</p>

<p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></pre></td>
<td class="lntd">
<pre class="chroma">server {
		server_name return.example.com;
		listen 80;
		
		root html/;
		error_page 404 403.html;
		return 403;
		location / {
				return 404 &#34;not found&#34;;
		}
}</pre></td></tr></table>
</div>
</div>
<p>问题：</p>

<ul>
<li>server与location下的return的关系？</li>
</ul>

<p>当同时打开server下的return和locatiion下的return，会直接由高级别的server段的return返回，因为return是rewrite阶段的指令，又返回会直接跳出。</p>

<ul>
<li>return与error_page指令的关系？</li>
</ul>

<p>当同时打开location下的return和error_page，error_page不会执行，虽然error_page比return级别高，但是由于return处于最开始的rewrite阶段，所以还是优先执行return而直接返回。</p>

<h4 id="2-5-3-rewrite重写url">2.5.3 rewrite重写url</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: rewrite regex replicement [flag]
Default: -
Context: server,location,if</pre></td></tr></table>
</div>
</div>
<p>将regex指定的url替换成replacement的新url，可以使用正则表达式及变量提取。当replacement以http[s]://或$schema开头，则直接返回302重定向。替换后的url根据flag指定的方式进行处理：</p>

<ul>
<li>&ndash;last：用replacement这个URL进行新的location匹配</li>
<li>&ndash;break：break指令停止当前脚本指令的执行，等价于独立的break指令</li>
<li>&ndash;redirect：返回302重定向</li>
<li>&ndash;permanent：返回301重定向</li>
</ul>

<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></pre></td>
<td class="lntd">
<pre class="chroma">server {
		.....
		root html/
		location /first {
				rewrite /first(.*) /second$1 last;
				return 200 &#39;first&#39;;
		}
		location /second {
				rewrite /second(.*) /third$1 break;
				return 200 &#39;second&#39;;
		}
		location /third {
				return 200 &#39;third&#39;;
		}
		location /redirect1 {
				rewrite /redirect1(.*) $1 permanent;
		}
		location /redirect2 {
				rewrite /redirect2(.*) $1 redirect;
		}
		location /redirect3 {
				rewrite /redirect3(.*) http://rewrite.example.com/$1;
		}
		location /redirect4 {
				rewrite /redirect4(.*) http://rewrite.example.com/$1 permanent;
		}
}</pre></td></tr></table>
</div>
</div>
<p>问题：</p>

<ol>
<li>return和rewrite指令的顺序关系？</li>
<li>访问/firxt/3.txt、/second/3.txt、/third/3.txt分别返回的是什么？</li>
<li>如果不携带flag会怎么样？</li>
</ol>

<p>解答：</p>

<ol>
<li>rewrite指令在后面的标志不是break的时候，会和return指令形成一个集合按照顺序执行。当flag是break的时候，直接返回结果。</li>
<li>访问/firxt/3.txt、/second/3.txt都会返回&rsquo;second&rsquo;，因为first执行了last继续匹配到/second</li>
<li>permanent返回301，redirect返回302，redirect3会返回302，redirect4会返回301.</li>
</ol>

<h4 id="2-5-4-条件判断if">2.5.4. 条件判断if</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: if (condition) {……}
Default：-
Context：server，location</pre></td></tr></table>
</div>
</div>
<p>if指令条件表达式</p>

<ul>
<li>检查变量为空或者值是否为0</li>
<li>将变量与字符串做匹配，使用=或者!=</li>
<li>将变量与正则表达式做匹配

<ul>
<li>大小写敏感：~或者!~</li>
<li>大小写不敏感：~*或者!~*</li>
</ul></li>
<li>检查文件是否存在 -f 或者 !-f</li>
<li>检查目录是否存在，使用-d或者!-d</li>
<li>检查文件、目录、软连接是否存在使用-e或者!-e</li>
<li>检查是否为可执行文件，使用-x或者!-x</li>
</ul>

<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></pre></td>
<td class="lntd">
<pre class="chroma">if ($http_user_agent ~ MSIE) {
		rewrite ^(.*)$ /msie/$1 break;
}
if ($http_cookie ~* &#34;id=([^;]+)(?:;|$)&#34;) {
		sed $id $1;
}
if ($request_method = POST){
		return 405;
}
if ($slow) {
		limit_rate 10k;
}
if ($invalid_referer) {
		return 403;
}</pre></td></tr></table>
</div>
</div>
<h4 id="2-5-5-find-config找到处理请求的location">2.5.5. find_config找到处理请求的location</h4>

<p>location指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: location [=|~|~*|^~] uri {……}
				location @name {……}
Default: -
Context: server location

# merge合并uri中连续 的&#34;/&#34; ,比如连续写了两个 / ,会合并成一个
Syntax: merge_slashes on | off;  
Default: merge_slashes on;
Context: http，server</pre></td></tr></table>
</div>
</div>
<p>location匹配规则：仅匹配URI忽略参数</p>

<ul>
<li>= 精确匹配 ^~匹配上后则不再进行正则匹配</li>
<li>正则表达式：~ 大小写敏感 ~* 忽略大小写</li>
<li>用于内部调整的命名 @</li>
</ul>

<p>location匹配顺序</p>

<p><img src="/images/posts/nginx_location_order.png" alt="" /></p>

<h4 id="2-5-6-对连接数限制的limit-conn">2.5.6. 对连接数限制的limit_conn</h4>

<p>在preaccess阶段有limit_req和limit_conn。限制每个客户端的并发连接数，ngx_http_limit_conn_module模块</p>

<ul>
<li>生效阶段：NGX_HTTP_PREACCESS_PHASE</li>
<li>默认编译进nginx，通过&ndash;without-http_limit_conn_module禁用</li>
<li>生小范围

<ul>
<li>全部worker进程，基于共享内存</li>
<li>进入preaccess阶段前不生效</li>
<li>限制的有效性取决于key的设计，依赖postread阶段的realip模块取到用户真实IP</li>
</ul></li>
</ul>

<p>定义共享内存（包括大小）以及key关键字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: limit_conn_zone key zone=name:size
Default: - 
Context: http</pre></td></tr></table>
</div>
</div>
<p>限制并发连接数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: limit_conn zone number;
Default: - 
Context: http,server,location</pre></td></tr></table>
</div>
</div>
<p>限制发生时的日志级别</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: limit_conn_log_level info|notice|warn|error;;
Default: limit_conn_log_level error;
Context: http,server,location</pre></td></tr></table>
</div>
</div>
<p>限制发生时向客户端返回的错误码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: limit_conn_status code;
Default: limit_conn_status 503
Context: http, server,location</pre></td></tr></table>
</div>
</div>
<h4 id="2-5-7-对连接数限制的limit-req">2.5.7. 对连接数限制的limit_req</h4>

<p>limit_req将用户的突发请求进行恒定请求速率，ngx_http_limit_req_module模块</p>

<ul>
<li>生效阶段：NGX_HTTP_PREACCESS_PHASE</li>
<li>默认编译进nginx，通过&ndash;without-http_limit_req_module禁用</li>
<li>生效算法：leaky bucket算法</li>
<li>生小范围

<ul>
<li>全部worker进程，基于共享内存</li>
<li>进入preaccess阶段前不生效</li>
</ul></li>
</ul>

<p>定义共享内存包括大小，以及key关键字和限制速率</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: limit_req_zone key zone=name:size rate=rate;
Default: - 
Context: http
# rate单位为r/s或者r/m</pre></td></tr></table>
</div>
</div>
<p>限制并发连接数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: limit_req zone=name [burst=number] [nodelay];
Default: - 
Context: http,server,location
# burst默认为0
# nodelay，对burst中的请求不再采用延时处理的做法，而是立刻处理</pre></td></tr></table>
</div>
</div>
<p>同时打开limit_conn和limit_req，会都生效，但是返回是limit_req的返回，因为req在conn之前</p>

<h4 id="2-5-8-对ip做限制的access模块">2.5.8. 对ip做限制的access模块</h4>

<p>access阶段控制请求是否可以继续向下访问</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: allow address|CIDE|unix:|all
Default: - 
Context: http,server,location,limit_except

Syntax: deny address|CIDE|unix:|all
Default: - 
Context: http,server,location,limit_except</pre></td></tr></table>
</div>
</div>
<p>当有多个语句设置的时候，会按照顺序向下匹配，当匹配到时就直接返回，不会继续执行了</p>

<h4 id="2-5-9-precontent阶段的try-files模块">2.5.9. precontent阶段的try_files模块</h4>

<p>模块ngx_http_try_files_module</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: try_files file ..... uri|code;
Default: - 
Context: server,location</pre></td></tr></table>
</div>
</div>
<p>依次视图访问多个url对应的文件（由root或者alias指令指定），当文件存在时直接返回文件内存，如果所有文件都不存在，则按最后一个url或者code返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></pre></td>
<td class="lntd">
<pre class="chroma">server {
		server_name tryfiles.example.com;
		root html/;
		location /first {
				try_files /a/a.html $uri $uri/index.html $uri.html @lasturl; # 依次寻找文件，$uri表示html/first文件
		}
		location @lasturl {
				return 200 &#34;lasturl!\n&#34;
		}
		location /second {
				try_files $uri $uri/index.htl =404;
		}
}</pre></td></tr></table>
</div>
</div>
<p>#### 2.5.10. precontent阶段的mirror模块</p>

<p>模块ngx_http_mirror_module默认编译进了nginx，处理请求时，生成自请求访问其他服务为，对子请求的返回值不做任何处理。对于多个环境处理用户流量很有帮助</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: mirror uri|off;
Default: mirror off;
Context: http,server,location

Syntax: mirror_request_body on|off;  # 是否将请求体发送到上游服务器
Default:mirror_request_body on;
Context: http,server,location</pre></td></tr></table>
</div>
</div>
<h3 id="2-5-11-static模块的三个变量">2.5.11. static模块的三个变量</h3>

<ol>
<li>request_filename 待访问文件的完整路径</li>
<li>document_root 由URI和root/alias规则生成的文件夹路径</li>

<li><p>realpath_root 将document_root中的软连接等换成真实路径</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">location /realpath/ {
		alias html/realpath;
		return 200 &#34;$request_filename:$document_root:$realpath_root&#34;
}

realpath为first目录的软连接</pre></td></tr></table>
</div>
</div></li>
</ol>

<p>返回结果： /usr/local/openresty/nginx/html/realpath/1.txt:/usr/local/openresty/nginx/html/realpath:/usr/local/openresty/nginx/html/first</p>

<h4 id="2-5-12-static模块url后面斜杆问题">2.5.12. static模块url后面斜杆问题</h4>

<p>static模块实现了root/alias功能时，发现访问目标是目录，但是URL末尾加上/时，会返回301重定向</p>

<h4 id="2-5-13-access日志详细用法">2.5.13. access日志详细用法</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: access_log path [format [buffer=size] [gzip [level] [flush=time] [if=condition] ];
				access_log off;
Default: access_log logs/access.log combined;
Context: http,server,location,if in location,limit_expect;</pre></td></tr></table>
</div>
</div>
<ul>
<li>Path 路径可以包含变量：不打开cache时每记录一条日志都需要打开、关闭日志文件</li>
<li>if通过变量值控制请求日志是否记录</li>
<li>日志缓存：

<ul>
<li>功能：批量将内存中的日志写入磁盘</li>
<li>写入磁盘的条件</li>
<li>所有待写入磁盘的日志超出缓存大小</li>
<li>达到flush指定过期时间</li>
<li>worker进程执行reopen命令或者正在关闭</li>
</ul></li>
<li>日志压缩

<ul>
<li>功能：批量压缩内存中日志再写入磁盘</li>
<li>buffer大小默认64KB</li>
<li>压缩级别默认1，最高9</li>
</ul></li>
</ul>

<p>当日志文件名包含变量时，每次写入都会打开关闭文件，可以通过open_log_file_cache进行优化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">Syntax: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time]
Default: open_log_file_cache off;
Context: http,server,location</pre></td></tr></table>
</div>
</div>
<ul>
<li>Max: 缓存内的最大文件句柄数，超出后用LRU算法淘汰</li>
<li>Inactive：文件访问完后在这段时间内不会关闭。默认10s</li>
<li>min_uses: 在inactive时间内使用次数超过min_uses才会继续在内存中使用。默认1</li>
<li>valid：超出valid时间后，将对缓存的日志文件检查是否存在。默认60s</li>
<li>off：关闭缓存功能</li>
</ul>

<h4 id="2-5-14-http过滤模块">2.5.14. HTTP过滤模块</h4>

<p>返回响应-加工响应内容。重点关注的4个模块</p>

<ul>
<li>copy_filter：复制包体内容</li>
<li>Postpone_filter：处理子请求</li>
<li>header_filter：构造响应头部</li>
<li>write_filter：发送响应</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Wayne</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-09-13
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/2020-08-25-sftp%E7%9A%84%E9%85%8D%E7%BD%AE/">
            <span class="next-text nav-default">Sftp的配置</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="wayne.one.wang@outlook.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Wayne One Wang</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: {equationNumbers: {autoNumber: "AMS"}},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
